/*! Sortable 1.8.4 - MIT | git://github.com/SortableJS/Sortable.git */

!(function (t) { 'use strict'; typeof define === 'function' && define.amd ? define(t) : typeof module !== 'undefined' && void 0 !== module.exports ? module.exports = t() : window.Sortable = t() }(function () { 'use strict'; if (typeof window === 'undefined' || !window.document) return function () { throw new Error('Sortable.js requires a window with a document') }; var U; var V; var f; var u; var q; var G; var h; var X; var Y; var A; var K; var n; var Z; var Q; var l; var s; var c; var p; var k; var J; var $; var tt; var et; var ot; var g; var nt; var I = []; var B = !1; var v = !1; var it = !1; var d = []; var rt = !1; var at = !1; var m = []; var i = /\s+/g; var lt = 'Sortable' + (new Date()).getTime(); var b = window; var st = b.document; var w = b.parseInt; var ct = b.setTimeout; var e = b.jQuery || b.Zepto; var o = b.Polymer; var r = { capture: !1, passive: !1 }; var dt = !!navigator.userAgent.match(/(?:Trident.*rv[ :]?11\.|msie|iemobile)/i); var _ = !!navigator.userAgent.match(/Edge/i); var y = !!navigator.userAgent.match(/firefox/i); var D = !(!navigator.userAgent.match(/safari/i) || navigator.userAgent.match(/chrome/i) || navigator.userAgent.match(/android/i)); var S = !!navigator.userAgent.match(/iP(ad|od|hone)/i); var T = _ || dt ? 'cssFloat' : 'float'; var a = 'draggable' in st.createElement('div'); var C = (function () { if (dt) return !1; var t = st.createElement('x'); return t.style.cssText = 'pointer-events:auto', t.style.pointerEvents === 'auto' }()); var ht = !1; var E = !1; var ut = Math.abs; var x = Math.min; var N = Math.max; var M = []; var P = function (t, e) { var o = Dt(t); var n = w(o.width) - w(o.paddingLeft) - w(o.paddingRight) - w(o.borderLeftWidth) - w(o.borderRightWidth); var i = Mt(t, 0, e); var r = Mt(t, 1, e); var a = i && Dt(i); var l = r && Dt(r); var s = a && w(a.marginLeft) + w(a.marginRight) + Lt(i).width; var c = l && w(l.marginLeft) + w(l.marginRight) + Lt(r).width; if (o.display === 'flex') return o.flexDirection === 'column' || o.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal'; if (o.display === 'grid') return o.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal'; if (i && a.float !== 'none') { var d = a.float === 'left' ? 'left' : 'right'; return !r || l.clear !== 'both' && l.clear !== d ? 'horizontal' : 'vertical' } return i && (a.display === 'block' || a.display === 'flex' || a.display === 'table' || a.display === 'grid' || n <= s && o[T] === 'none' || r && o[T] === 'none' && n < s + c) ? 'vertical' : 'horizontal' }; var O = function (t, e) { if (!t || !t.getBoundingClientRect) return H(); var o = t; var n = !1; do { if (o.clientWidth < o.scrollWidth || o.clientHeight < o.scrollHeight) { var i = Dt(o); if (o.clientWidth < o.scrollWidth && (i.overflowX == 'auto' || i.overflowX == 'scroll') || o.clientHeight < o.scrollHeight && (i.overflowY == 'auto' || i.overflowY == 'scroll')) { if (!o || !o.getBoundingClientRect || o === st.body) return H(); if (n || e) return o; n = !0 } } } while (o = o.parentNode); return H() }; var H = function () { return dt ? st.documentElement : st.scrollingElement }; var ft = function (t, e, o) { t.scrollLeft += e, t.scrollTop += o }; var R = It(function (o, t, e, n) { if (t.scroll) { var i = e ? e[lt] : window; var r = t.scrollSensitivity; var a = t.scrollSpeed; var l = o.clientX; var s = o.clientY; var c = H(); var d = !1; Y !== e && (L(), X = t.scroll, A = t.scrollFn, !0 === X && (X = O(e, !0), Y = X)); var h = 0; var u = X; do { var f; var p; var g; var v; var m; var b; var w; var _; var y; var D = u; var S = Lt(D); var T = S.top; var C = S.bottom; var E = S.left; var x = S.right; var N = S.width; var M = S.height; if (f = D.scrollWidth, p = D.scrollHeight, g = Dt(D), _ = D.scrollLeft, y = D.scrollTop, w = D === c ? (b = N < f && (g.overflowX === 'auto' || g.overflowX === 'scroll' || g.overflowX === 'visible'), M < p && (g.overflowY === 'auto' || g.overflowY === 'scroll' || g.overflowY === 'visible')) : (b = N < f && (g.overflowX === 'auto' || g.overflowX === 'scroll'), M < p && (g.overflowY === 'auto' || g.overflowY === 'scroll')), v = b && (ut(x - l) <= r && _ + N < f) - (ut(E - l) <= r && !!_), m = w && (ut(C - s) <= r && y + M < p) - (ut(T - s) <= r && !!y), !I[h]) for (var P = 0; P <= h; P++)I[P] || (I[P] = {}); I[h].vx == v && I[h].vy == m && I[h].el === D || (I[h].el = D, I[h].vx = v, I[h].vy = m, clearInterval(I[h].pid), !D || v == 0 && m == 0 || (d = !0, I[h].pid = setInterval(function () { n && this.layer === 0 && (mt.active._emulateDragOver(!0), mt.active._onTouchMove(k, !0)); var t = I[this.layer].vy ? I[this.layer].vy * a : 0; var e = I[this.layer].vx ? I[this.layer].vx * a : 0; typeof A === 'function' && A.call(i, e, t, o, k, I[this.layer].el) !== 'continue' || ft(I[this.layer].el, e, t) }.bind({ layer: h }), 24))), h++ } while (t.bubbleScroll && u !== c && (u = O(u, !1))); B = d } }, 30); var L = function () { I.forEach(function (t) { clearInterval(t.pid) }), I = [] }; var W = function (t) { function s (a, l) { return function (t, e, o, n) { var i = t.options.group.name && e.options.group.name && t.options.group.name === e.options.group.name; if (a == null && (l || i)) return !0; if (a == null || !1 === a) return !1; if (l && a === 'clone') return a; if (typeof a === 'function') return s(a(t, e, o, n), l)(t, e, o, n); var r = (l ? t : e).options.group.name; return !0 === a || typeof a === 'string' && a === r || a.join && a.indexOf(r) > -1 } } var e = {}; var o = t.group; o && typeof o === 'object' || (o = { name: o }), e.name = o.name, e.checkPull = s(o.pull, !0), e.checkPut = s(o.put), e.revertClone = o.revertClone, t.group = e }; var F = function (t) { U && U.parentNode && U.parentNode[lt] && U.parentNode[lt]._computeIsAligned(t) }; var pt = function (t, e) { for (var o = e; !o[lt];)o = o.parentNode; return t === o }; var gt = function (t, e, o) { for (var n = t.parentNode; n && !n[lt];)n = n.parentNode; n && n[lt][o](Bt(e, { artificialBubble: !0 })) }; var z = function () { !C && f && Dt(f, 'display', 'none') }; var j = function () { !C && f && Dt(f, 'display', '') }; st.addEventListener('click', function (t) { if (it) return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), it = !1 }, !0); var vt; var t = function (t) { if (t = t.touches ? t.touches[0] : t, U) { var e = (function (t, e) { for (var o = 0; o < d.length; o++) if (!Pt(d[o])) { var n = Lt(d[o]); var i = d[o][lt].options.emptyInsertThreshold; var r = t >= n.left - i && t <= n.right + i; var a = e >= n.top - i && e <= n.bottom + i; if (r && a) return d[o] } }(t.clientX, t.clientY)); e && e[lt]._onDragOver({ clientX: t.clientX, clientY: t.clientY, target: e, rootEl: e }) } }; function mt (t, e) { if (!t || !t.nodeType || t.nodeType !== 1) throw 'Sortable: `el` must be HTMLElement, not ' + {}.toString.call(t); this.el = t, this.options = e = Bt({}, e), t[lt] = this; var o = { group: null, sort: !0, disabled: !1, store: null, handle: null, scroll: !0, scrollSensitivity: 30, scrollSpeed: 10, bubbleScroll: !0, draggable: /[uo]l/i.test(t.nodeName) ? '>li' : '>*', swapThreshold: 1, invertSwap: !1, invertedSwapThreshold: null, removeCloneOnHide: !0, direction: function () { return P(t, this.options) }, ghostClass: 'sortable-ghost', chosenClass: 'sortable-chosen', dragClass: 'sortable-drag', ignore: 'a, img', filter: null, preventOnFilter: !0, animation: 0, easing: null, setData: function (t, e) { t.setData('Text', e.textContent) }, dropBubble: !1, dragoverBubble: !1, dataIdAttr: 'data-id', delay: 0, touchStartThreshold: w(window.devicePixelRatio, 10) || 1, forceFallback: !1, fallbackClass: 'sortable-fallback', fallbackOnBody: !1, fallbackTolerance: 0, fallbackOffset: { x: 0, y: 0 }, supportPointer: !1 !== mt.supportPointer && ('PointerEvent' in window || window.navigator && 'msPointerEnabled' in window.navigator), emptyInsertThreshold: 5 }; for (var n in o)!(n in e) && (e[n] = o[n]); for (var i in W(e), this)i.charAt(0) === '_' && typeof this[i] === 'function' && (this[i] = this[i].bind(this)); this.nativeDraggable = !e.forceFallback && a, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? wt(t, 'pointerdown', this._onTapStart) : (wt(t, 'mousedown', this._onTapStart), wt(t, 'touchstart', this._onTapStart)), this.nativeDraggable && (wt(t, 'dragover', this), wt(t, 'dragenter', this)), d.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []) } function bt (t, e, o, n) { if (t) { o = o || st; do { if (e != null && (e[0] === '>' && t.parentNode === o && kt(t, e.substring(1)) || kt(t, e)) || n && t === o) return t; if (t === o) break } while (t = (i = t).host && i !== st && i.host.nodeType ? i.host : i.parentNode) } var i; return null } function wt (t, e, o) { t.addEventListener(e, o, r) } function _t (t, e, o) { t.removeEventListener(e, o, r) } function yt (t, e, o) { if (t && e) if (t.classList)t.classList[o ? 'add' : 'remove'](e); else { var n = (' ' + t.className + ' ').replace(i, ' ').replace(' ' + e + ' ', ' '); t.className = (n + (o ? ' ' + e : '')).replace(i, ' ') } } function Dt (t, e, o) { var n = t && t.style; if (n) { if (void 0 === o) return st.defaultView && st.defaultView.getComputedStyle ? o = st.defaultView.getComputedStyle(t, '') : t.currentStyle && (o = t.currentStyle), void 0 === e ? o : o[e]; e in n || e.indexOf('webkit') !== -1 || (e = '-webkit-' + e), n[e] = o + (typeof o === 'string' ? '' : 'px') } } function St (t) { var e = ''; do { var o = Dt(t, 'transform'); o && o !== 'none' && (e = o + ' ' + e) } while (t = t.parentNode); return window.DOMMatrix ? new DOMMatrix(e) : window.WebKitCSSMatrix ? new WebKitCSSMatrix(e) : window.CSSMatrix ? new CSSMatrix(e) : void 0 } function Tt (t, e, o) { if (t) { var n = t.getElementsByTagName(e); var i = 0; var r = n.length; if (o) for (;i < r; i++)o(n[i], i); return n } return [] } function Ct (t, e, o, n, i, r, a, l, s) { var c; var d = (t = t || e[lt]).options; var h = 'on' + o.charAt(0).toUpperCase() + o.substr(1); !window.CustomEvent || dt || _ ? (c = st.createEvent('Event')).initEvent(o, !0, !0) : c = new CustomEvent(o, { bubbles: !0, cancelable: !0 }), c.to = i || e, c.from = r || e, c.item = n || e, c.clone = u, c.oldIndex = a, c.newIndex = l, c.originalEvent = s, c.pullMode = Q ? Q.lastPutMode : void 0, e && e.dispatchEvent(c), d[h] && d[h].call(t, c) } function Et (t, e, o, n, i, r, a, l) { var s; var c; var d = t[lt]; var h = d.options.onMove; return !window.CustomEvent || dt || _ ? (s = st.createEvent('Event')).initEvent('move', !0, !0) : s = new CustomEvent('move', { bubbles: !0, cancelable: !0 }), s.to = e, s.from = t, s.dragged = o, s.draggedRect = n, s.related = i || e, s.relatedRect = r || Lt(e), s.willInsertAfter = l, s.originalEvent = a, t.dispatchEvent(s), h && (c = h.call(d, s, a)), c } function xt (t) { t.draggable = !1 } function Nt () { ht = !1 } function Mt (t, e, o) { for (var n = 0, i = 0, r = t.children; i < r.length;) { if (r[i].style.display !== 'none' && r[i] !== f && r[i] !== U && bt(r[i], o.draggable, t, !1)) { if (n === e) return r[i]; n++ }i++ } return null } function Pt (t) { for (var e = t.lastElementChild; e && (e === f || e.style.display === 'none');)e = e.previousElementSibling; return e || null } function Xt (t) { return At(U) < At(t) ? 1 : -1 } function Yt (t) { for (var e = t.tagName + t.className + t.src + t.href + t.textContent, o = e.length, n = 0; o--;)n += e.charCodeAt(o); return n.toString(36) } function At (t, e) { var o = 0; if (!t || !t.parentNode) return -1; for (;t && (t = t.previousElementSibling);)t.nodeName.toUpperCase() !== 'TEMPLATE' && t !== u && o++; return o } function kt (t, e) { if (t) try { if (t.matches) return t.matches(e); if (t.msMatchesSelector) return t.msMatchesSelector(e); if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e) } catch (t) { return !1 } return !1 } function It (o, n) { return function () { if (!vt) { var t = arguments; var e = this; vt = ct(function () { t.length === 1 ? o.call(e, t[0]) : o.apply(e, t), vt = void 0 }, n) } } } function Bt (t, e) { if (t && e) for (var o in e)e.hasOwnProperty(o) && (t[o] = e[o]); return t } function Ot (t) { return o && o.dom ? o.dom(t).cloneNode(!0) : e ? e(t).clone(!0)[0] : t.cloneNode(!0) } function Ht (t) { return ct(t, 0) } function Rt (t) { return clearTimeout(t) } function Lt (t, e, o, n) { if (t.getBoundingClientRect || t === b) { var i, r, a, l, s, c, d; if (d = t !== b && t !== H() ? (r = (i = t.getBoundingClientRect()).top, a = i.left, l = i.bottom, s = i.right, c = i.height, i.width) : (a = r = 0, l = window.innerHeight, s = window.innerWidth, c = window.innerHeight, window.innerWidth), n && t !== b && (o = o || t.parentNode, !dt)) do { if (o && o.getBoundingClientRect && Dt(o, 'transform') !== 'none') { var h = o.getBoundingClientRect(); r -= h.top + w(Dt(o, 'border-top-width')), a -= h.left + w(Dt(o, 'border-left-width')), l = r + i.height, s = a + i.width; break } } while (o = o.parentNode); if (e && t !== b) { var u = St(o || t); var f = u && u.a; var p = u && u.d; u && (l = (r /= p) + (c /= p), s = (a /= f) + (d /= f)) } return { top: r, left: a, bottom: l, right: s, width: d, height: c } } } function Wt (t, e) { for (var o = O(t, !0), n = Lt(t)[e]; o;) { var i = Lt(o)[e]; if (!(e === 'top' || e === 'left' ? i <= n : n <= i)) return o; if (o === H()) break; o = O(o, !1) } return !1 } function Ft (t) { var e = 0; var o = 0; var n = H(); if (t) do { var i = St(t); var r = i.a; var a = i.d; e += t.scrollLeft * r, o += t.scrollTop * a } while (t !== n && (t = t.parentNode)); return [e, o] } return wt(st, 'dragover', t), wt(st, 'mousemove', t), wt(st, 'touchmove', t), mt.prototype = { constructor: mt, _computeIsAligned: function (t) { var e; if (f && !C ? (z(), e = st.elementFromPoint(t.clientX, t.clientY), j()) : e = t.target, e = bt(e, this.options.draggable, this.el, !1), !E && U && U.parentNode === this.el) { for (var o, n, i, r, a, l, s, c, d = this.el.children, h = 0; h < d.length; h++)bt(d[h], this.options.draggable, this.el, !1) && d[h] !== e && (d[h].sortableMouseAligned = (o = t.clientX, n = t.clientY, i = d[h], r = this._getDirection(t, null), this.options, void 0, a = Lt(i), l = r === 'vertical' ? a.left : a.top, s = r === 'vertical' ? a.right : a.bottom, l < (c = r === 'vertical' ? o : n) && c < s)); bt(e, this.options.draggable, this.el, !0) || ($ = null), E = !0, ct(function () { E = !1 }, 30) } }, _getDirection: function (t, e) { return typeof this.options.direction === 'function' ? this.options.direction.call(this, t, e, U) : this.options.direction }, _onTapStart: function (t) { if (t.cancelable) { var e; var o = this; var n = this.el; var i = this.options; var r = i.preventOnFilter; var a = t.type; var l = t.touches && t.touches[0]; var s = (l || t).target; var c = t.target.shadowRoot && (t.path && t.path[0] || t.composedPath && t.composedPath()[0]) || s; var d = i.filter; if ((function (t) { M.length = 0; var e = t.getElementsByTagName('input'); var o = e.length; for (;o--;) { var n = e[o]; n.checked && M.push(n) } }(n)), (!dt || t.artificialBubble || pt(n, s)) && !U && !(/mousedown|pointerdown/.test(a) && t.button !== 0 || i.disabled || c.isContentEditable)) if (s = bt(s, i.draggable, n, !1)) { if (h !== s) { if (e = At(s, i.draggable), typeof d === 'function') { if (d.call(this, t, s, this)) return Ct(o, c, 'filter', s, n, n, e), void (r && t.cancelable && t.preventDefault()) } else if (d && (d = d.split(',').some(function (t) { if (t = bt(c, t.trim(), n, !1)) return Ct(o, t, 'filter', s, n, n, e), !0 }))) return void (r && t.cancelable && t.preventDefault()); i.handle && !bt(c, i.handle, n, !1) || this._prepareDragStart(t, l, s, e) } } else dt && gt(n, t, '_onTapStart') } }, _handleAutoScroll: function (e, o) { if (U && this.options.scroll) { var n = e.clientX; var i = e.clientY; var t = st.elementFromPoint(n, i); var r = this; if (o || _ || dt || D) { R(e, r.options, t, o); var a = O(t, !0); !B || l && n === s && i === c || (l && clearInterval(l), l = setInterval(function () { if (U) { var t = O(st.elementFromPoint(n, i), !0); t !== a && (a = t, L(), R(e, r.options, a, o)) } }, 10), s = n, c = i) } else { if (!r.options.bubbleScroll || O(t, !0) === H()) return void L(); R(e, r.options, O(t, !1), !1) } } }, _prepareDragStart: function (t, e, o, n) { var i; var r = this; var a = r.el; var l = r.options; var s = a.ownerDocument; o && !U && o.parentNode === a && (q = a, V = (U = o).parentNode, G = U.nextSibling, h = o, Z = l.group, K = n, p = { target: U, clientX: (e || t).clientX, clientY: (e || t).clientY }, this._lastX = (e || t).clientX, this._lastY = (e || t).clientY, U.style['will-change'] = 'all', U.style.transition = '', U.style.transform = '', i = function () { r._disableDelayedDragEvents(), !y && r.nativeDraggable && (U.draggable = !0), r._triggerDragStart(t, e), Ct(r, q, 'choose', U, q, q, K), yt(U, l.chosenClass, !0) }, l.ignore.split(',').forEach(function (t) { Tt(U, t.trim(), xt) }), l.supportPointer ? wt(s, 'pointerup', r._onDrop) : (wt(s, 'mouseup', r._onDrop), wt(s, 'touchend', r._onDrop), wt(s, 'touchcancel', r._onDrop)), y && this.nativeDraggable && (this.options.touchStartThreshold = 4, U.draggable = !0), !l.delay || this.nativeDraggable && (_ || dt) ? i() : (wt(s, 'mouseup', r._disableDelayedDrag), wt(s, 'touchend', r._disableDelayedDrag), wt(s, 'touchcancel', r._disableDelayedDrag), wt(s, 'mousemove', r._delayedDragTouchMoveHandler), wt(s, 'touchmove', r._delayedDragTouchMoveHandler), l.supportPointer && wt(s, 'pointermove', r._delayedDragTouchMoveHandler), r._dragStartTimer = ct(i, l.delay))) }, _delayedDragTouchMoveHandler: function (t) { var e = t.touches ? t.touches[0] : t; N(ut(e.clientX - this._lastX), ut(e.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag() }, _disableDelayedDrag: function () { U && xt(U), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents() }, _disableDelayedDragEvents: function () { var t = this.el.ownerDocument; _t(t, 'mouseup', this._disableDelayedDrag), _t(t, 'touchend', this._disableDelayedDrag), _t(t, 'touchcancel', this._disableDelayedDrag), _t(t, 'mousemove', this._delayedDragTouchMoveHandler), _t(t, 'touchmove', this._delayedDragTouchMoveHandler), _t(t, 'pointermove', this._delayedDragTouchMoveHandler) }, _triggerDragStart: function (t, e) { e = e || (t.pointerType == 'touch' ? t : null), !this.nativeDraggable || e ? this.options.supportPointer ? wt(st, 'pointermove', this._onTouchMove) : wt(st, e ? 'touchmove' : 'mousemove', this._onTouchMove) : (wt(U, 'dragend', this), wt(q, 'dragstart', this._onDragStart)); try { st.selection ? Ht(function () { st.selection.empty() }) : window.getSelection().removeAllRanges() } catch (t) {} }, _dragStarted: function (t, e) { if (v = !1, q && U) { this.nativeDraggable && (wt(st, 'dragover', this._handleAutoScroll), wt(st, 'dragover', F)); var o = this.options; !t && yt(U, o.dragClass, !1), yt(U, o.ghostClass, !0), Dt(U, 'transform', ''), mt.active = this, t && this._appendGhost(), Ct(this, q, 'start', U, q, q, K, void 0, e) } else this._nulling() }, _emulateDragOver: function (t) { if (k) { if (this._lastX === k.clientX && this._lastY === k.clientY && !t) return; this._lastX = k.clientX, this._lastY = k.clientY, z(); for (var e = st.elementFromPoint(k.clientX, k.clientY), o = e; e && e.shadowRoot;)o = e = e.shadowRoot.elementFromPoint(k.clientX, k.clientY); if (o) do { if (o[lt]) if (o[lt]._onDragOver({ clientX: k.clientX, clientY: k.clientY, target: e, rootEl: o }) && !this.options.dragoverBubble) break; e = o } while (o = o.parentNode); U.parentNode[lt]._computeIsAligned(k), j() } }, _onTouchMove: function (t, e) { if (p) { var o = this.options; var n = o.fallbackTolerance; var i = o.fallbackOffset; var r = t.touches ? t.touches[0] : t; var a = f && St(f); var l = f && a && a.a; var s = f && a && a.d; var c = S && g && Ft(g); var d = (r.clientX - p.clientX + i.x) / (l || 1) + (c ? c[0] - m[0] : 0) / (l || 1); var h = (r.clientY - p.clientY + i.y) / (s || 1) + (c ? c[1] - m[1] : 0) / (s || 1); var u = t.touches ? 'translate3d(' + d + 'px,' + h + 'px,0)' : 'translate(' + d + 'px,' + h + 'px)'; if (!mt.active && !v) { if (n && x(ut(r.clientX - this._lastX), ut(r.clientY - this._lastY)) < n) return; this._onDragStart(t, !0) }!e && this._handleAutoScroll(r, !0), J = !0, k = r, Dt(f, 'webkitTransform', u), Dt(f, 'mozTransform', u), Dt(f, 'msTransform', u), Dt(f, 'transform', u), t.cancelable && t.preventDefault() } }, _appendGhost: function () { if (!f) { var t = this.options.fallbackOnBody ? st.body : q; var e = Lt(U, !0, t, !S); var o = (Dt(U), this.options); if (S) { for (g = t; Dt(g, 'position') === 'static' && Dt(g, 'transform') === 'none' && g !== st;)g = g.parentNode; if (g !== st) { var n = Lt(g, !0); e.top -= n.top, e.left -= n.left }g !== st.body && g !== st.documentElement ? (g === st && (g = H()), e.top += g.scrollTop, e.left += g.scrollLeft) : g = H(), m = Ft(g) }yt(f = U.cloneNode(!0), o.ghostClass, !1), yt(f, o.fallbackClass, !0), yt(f, o.dragClass, !0), Dt(f, 'box-sizing', 'border-box'), Dt(f, 'margin', 0), Dt(f, 'top', e.top), Dt(f, 'left', e.left), Dt(f, 'width', e.width), Dt(f, 'height', e.height), Dt(f, 'opacity', '0.8'), Dt(f, 'position', S ? 'absolute' : 'fixed'), Dt(f, 'zIndex', '100000'), Dt(f, 'pointerEvents', 'none'), t.appendChild(f) } }, _onDragStart: function (t, e) { var o = this; var n = t.dataTransfer; var i = o.options; (u = Ot(U)).draggable = !1, u.style['will-change'] = '', this._hideClone(), yt(u, o.options.chosenClass, !1), o._cloneId = Ht(function () { o.options.removeCloneOnHide || q.insertBefore(u, U), Ct(o, q, 'clone', U) }), !e && yt(U, i.dragClass, !0), e ? (it = !0, o._loopId = setInterval(o._emulateDragOver, 50)) : (_t(st, 'mouseup', o._onDrop), _t(st, 'touchend', o._onDrop), _t(st, 'touchcancel', o._onDrop), n && (n.effectAllowed = 'move', i.setData && i.setData.call(o, n, U)), wt(st, 'drop', o), Dt(U, 'transform', 'translateZ(0)')), v = !0, o._dragStartId = Ht(o._dragStarted.bind(o, e, t)), wt(st, 'selectstart', o), D && Dt(st.body, 'user-select', 'none') }, _onDragOver: function (e) { var o; var n; var t; var i = this.el; var r = e.target; var a = this.options; var l = a.group; var s = mt.active; var c = Z === l; var d = a.sort; var h = this; if (!ht && (!dt || e.rootEl || e.artificialBubble || pt(i, r))) { if (void 0 !== e.preventDefault && e.cancelable && e.preventDefault(), J = !0, r = bt(r, a.draggable, i, !0), bt(e.target, null, U, !0) || r.animated) return z(!1); if (r !== U && (it = !1), s && !a.disabled && (c ? d || (t = !q.contains(U)) : Q === this || (this.lastPutMode = Z.checkPull(this, s, U, e)) && l.checkPut(this, s, U, e))) { var u = this._getDirection(e, r); if (o = Lt(U), t) return this._hideClone(), V = q, G ? q.insertBefore(U, G) : q.appendChild(U), z(!0); var f = Pt(i); if (f && (I = e, B = u, O = Lt(Pt(i)), H = B === 'vertical' ? I.clientY : I.clientX, R = B === 'vertical' ? I.clientX : I.clientY, L = B === 'vertical' ? O.bottom : O.right, W = B === 'vertical' ? O.left : O.top, F = B === 'vertical' ? O.right : O.bottom, !(B === 'vertical' ? F + 10 < R || R <= F && L < H && W <= R : L < H && W < R || H <= L && F + 10 < R) || f.animated)) { if (r && r !== U && r.parentNode === i) { var p; var g = 0; var v = r.sortableMouseAligned; var m = U.parentNode !== i; var b = u === 'vertical' ? 'top' : 'left'; var w = Wt(r, 'top') || Wt(U, 'top'); var _ = w ? w.scrollTop : void 0; if ($ !== r && (et = null, p = Lt(r)[b], rt = !1), C = r, E = u, x = (T = U) === U && nt || Lt(T), N = C === U && nt || Lt(C), M = E === 'vertical' ? x.left : x.top, P = E === 'vertical' ? x.right : x.bottom, X = E === 'vertical' ? x.width : x.height, Y = E === 'vertical' ? N.left : N.top, A = E === 'vertical' ? N.right : N.bottom, k = E === 'vertical' ? N.width : N.height, et = (M === Y || P === A || M + X / 2 === Y + k / 2) && v || m || w || a.invertSwap || et === 'insert' || et === 'swap' ? (et !== 'swap' && (at = a.invertSwap || m), g = (function (t, e, o, n, i, r, a) { var l = Lt(e); var s = o === 'vertical' ? t.clientY : t.clientX; var c = o === 'vertical' ? l.height : l.width; var d = o === 'vertical' ? l.top : l.left; var h = o === 'vertical' ? l.bottom : l.right; var u = Lt(U); var f = !1; if (!r) if (a && ot < c * n) if (!rt && (tt === 1 ? d + c * i / 2 < s : s < h - c * i / 2) && (rt = !0), rt)f = !0; else { o === 'vertical' ? u.top : u.left, o === 'vertical' ? u.bottom : u.right; if (tt === 1 ? s < d + ot : h - ot < s) return -1 * tt } else if (d + c * (1 - n) / 2 < s && s < h - c * (1 - n) / 2) return Xt(e); if ((f = f || r) && (s < d + c * i / 2 || h - c * i / 2 < s)) return d + c / 2 < s ? 1 : -1; return 0 }(e, r, u, a.swapThreshold, a.invertedSwapThreshold == null ? a.swapThreshold : a.invertedSwapThreshold, at, $ === r)), 'swap') : (g = Xt(r), 'insert'), g === 0) return z(!1); nt = null, tt = g, n = Lt($ = r); var y = r.nextElementSibling; var D = !1; var S = Et(q, i, U, o, r, n, e, D = g === 1); if (!1 !== S) return S !== 1 && S !== -1 || (D = S === 1), ht = !0, ct(Nt, 30), c ? s._hideClone() : s._showClone(this), D && !y ? i.appendChild(U) : r.parentNode.insertBefore(U, D ? y : r), w && ft(w, 0, _ - w.scrollTop), V = U.parentNode, void 0 === p || at || (ot = ut(p - Lt(r)[b])), j(), z(!0) } } else if (f && i === e.target && (r = f), r && (n = Lt(r)), c ? s._hideClone() : s._showClone(this), !1 !== Et(q, i, U, o, r, n, e, !!r)) return i.appendChild(U), V = i, nt = null, j(), z(!0); if (i.contains(U)) return z(!1) } var T, C, E, x, N, M, P, X, Y, A, k, I, B, O, H, R, L, W, F; return dt && !e.rootEl && gt(i, e, '_onDragOver'), !1 } function z (t) { return t && (c ? s._hideClone() : s._showClone(h), s && (yt(U, Q ? Q.options.ghostClass : s.options.ghostClass, !1), yt(U, a.ghostClass, !0)), Q !== h && h !== mt.active ? Q = h : h === mt.active && (Q = null), o && h._animate(o, U), r && n && h._animate(n, r)), (r === U && !U.animated || r === i && !r.animated) && ($ = null), a.dragoverBubble || e.rootEl || r === st || (h._handleAutoScroll(e), U.parentNode[lt]._computeIsAligned(e)), !a.dragoverBubble && e.stopPropagation && e.stopPropagation(), !0 } function j () { Ct(h, q, 'change', r, i, q, K, At(U, a.draggable), e) } }, _animate: function (t, e) { var o = this.options.animation; if (o) { var n = Lt(e); if (e === U && (nt = n), t.nodeType === 1 && (t = Lt(t)), t.left + t.width / 2 !== n.left + n.width / 2 || t.top + t.height / 2 !== n.top + n.height / 2) { var i = St(this.el); var r = i && i.a; var a = i && i.d; Dt(e, 'transition', 'none'), Dt(e, 'transform', 'translate3d(' + (t.left - n.left) / (r || 1) + 'px,' + (t.top - n.top) / (a || 1) + 'px,0)'), e.offsetWidth, Dt(e, 'transition', 'transform ' + o + 'ms' + (this.options.easing ? ' ' + this.options.easing : '')), Dt(e, 'transform', 'translate3d(0,0,0)') } typeof e.animated === 'number' && clearTimeout(e.animated), e.animated = ct(function () { Dt(e, 'transition', ''), Dt(e, 'transform', ''), e.animated = !1 }, o) } }, _offUpEvents: function () { var t = this.el.ownerDocument; _t(st, 'touchmove', this._onTouchMove), _t(st, 'pointermove', this._onTouchMove), _t(t, 'mouseup', this._onDrop), _t(t, 'touchend', this._onDrop), _t(t, 'pointerup', this._onDrop), _t(t, 'touchcancel', this._onDrop), _t(st, 'selectstart', this) }, _onDrop: function (t) { var e = this.el; var o = this.options; rt = at = B = v = !1, clearInterval(this._loopId), clearInterval(l), L(), clearTimeout(vt), vt = void 0, clearTimeout(this._dragStartTimer), Rt(this._cloneId), Rt(this._dragStartId), _t(st, 'mousemove', this._onTouchMove), this.nativeDraggable && (_t(st, 'drop', this), _t(e, 'dragstart', this._onDragStart), _t(st, 'dragover', this._handleAutoScroll), _t(st, 'dragover', F)), D && Dt(st.body, 'user-select', ''), this._offUpEvents(), t && (J && (t.cancelable && t.preventDefault(), !o.dropBubble && t.stopPropagation()), f && f.parentNode && f.parentNode.removeChild(f), (q === V || Q && Q.lastPutMode !== 'clone') && u && u.parentNode && u.parentNode.removeChild(u), U && (this.nativeDraggable && _t(U, 'dragend', this), xt(U), U.style['will-change'] = '', yt(U, Q ? Q.options.ghostClass : this.options.ghostClass, !1), yt(U, this.options.chosenClass, !1), Ct(this, q, 'unchoose', U, V, q, K, null, t), q !== V ? ((n = At(U, o.draggable)) >= 0 && (Ct(null, V, 'add', U, V, q, K, n, t), Ct(this, q, 'remove', U, V, q, K, n, t), Ct(null, V, 'sort', U, V, q, K, n, t), Ct(this, q, 'sort', U, V, q, K, n, t)), Q && Q.save()) : U.nextSibling !== G && (n = At(U, o.draggable)) >= 0 && (Ct(this, q, 'update', U, V, q, K, n, t), Ct(this, q, 'sort', U, V, q, K, n, t)), mt.active && (n != null && n !== -1 || (n = K), Ct(this, q, 'end', U, V, q, K, n, t), this.save()))), this._nulling() }, _nulling: function () { q = U = V = f = G = u = h = X = Y = I.length = l = s = c = p = k = J = n = K = $ = tt = nt = Q = Z = mt.active = null, M.forEach(function (t) { t.checked = !0 }), M.length = 0 }, handleEvent: function (t) { switch (t.type) { case 'drop':case 'dragend':this._onDrop(t); break; case 'dragenter':case 'dragover':U && (this._onDragOver(t), (function (t) { t.dataTransfer && (t.dataTransfer.dropEffect = 'move'); t.cancelable && t.preventDefault() }(t))); break; case 'selectstart':t.preventDefault() } }, toArray: function () { for (var t, e = [], o = this.el.children, n = 0, i = o.length, r = this.options; n < i; n++)bt(t = o[n], r.draggable, this.el, !1) && e.push(t.getAttribute(r.dataIdAttr) || Yt(t)); return e }, sort: function (t) { var n = {}; var i = this.el; this.toArray().forEach(function (t, e) { var o = i.children[e]; bt(o, this.options.draggable, i, !1) && (n[t] = o) }, this), t.forEach(function (t) { n[t] && (i.removeChild(n[t]), i.appendChild(n[t])) }) }, save: function () { var t = this.options.store; t && t.set && t.set(this) }, closest: function (t, e) { return bt(t, e || this.options.draggable, this.el, !1) }, option: function (t, e) { var o = this.options; if (void 0 === e) return o[t]; o[t] = e, t === 'group' && W(o) }, destroy: function () { var t = this.el; t[lt] = null, _t(t, 'mousedown', this._onTapStart), _t(t, 'touchstart', this._onTapStart), _t(t, 'pointerdown', this._onTapStart), this.nativeDraggable && (_t(t, 'dragover', this), _t(t, 'dragenter', this)), Array.prototype.forEach.call(t.querySelectorAll('[draggable]'), function (t) { t.removeAttribute('draggable') }), this._onDrop(), d.splice(d.indexOf(this.el), 1), this.el = t = null }, _hideClone: function () { u.cloneHidden || (Dt(u, 'display', 'none'), u.cloneHidden = !0, u.parentNode && this.options.removeCloneOnHide && u.parentNode.removeChild(u)) }, _showClone: function (t) { t.lastPutMode === 'clone' ? u.cloneHidden && (q.contains(U) && !this.options.group.revertClone ? q.insertBefore(u, U) : G ? q.insertBefore(u, G) : q.appendChild(u), this.options.group.revertClone && this._animate(U, u), Dt(u, 'display', ''), u.cloneHidden = !1) : this._hideClone() } }, wt(st, 'touchmove', function (t) { (mt.active || v) && t.cancelable && t.preventDefault() }), mt.utils = { on: wt, off: _t, css: Dt, find: Tt, is: function (t, e) { return !!bt(t, e, t, !1) }, extend: Bt, throttle: It, closest: bt, toggleClass: yt, clone: Ot, index: At, nextTick: Ht, cancelNextTick: Rt, detectDirection: P, getChild: Mt }, mt.create = function (t, e) { return new mt(t, e) }, mt.version = '1.8.4', mt }))
